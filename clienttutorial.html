<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QtProtobuf: QtProtobuf Client Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://github.com/semlanik/qtprotobuf" style="color:#404244; text-decoration: none;">QtProtobuf</a>
   &#160;<span id="projectnumber">0.6</span>
   </div>
   <div id="projectbrief">Protobuf plugin to generate Qt classes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">QtProtobuf Client Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial will show how to use QtProtobuf client with some existing server and specified communication protocol.</p>
<h2><a class="anchor" id="clienttutorial_dependencies"></a>
Add QtProtobuf package to CMake project</h2>
<p>After you successfully installed/built QtProtobuf (see <a href="https://github.com/semlanik/qtprotobuf">README.md</a>) with complete set of dependencies you may start creation either CMake or qmake project in QtCreator. Now we need to tell our project about QtProtobuf. Add following line in your CMakeLists.txt to add QtProtobuf as project dependency:</p>
<div class="fragment"><div class="line">find_package(QtProtobuf COMPONENTS ProtobufGenerator Protobuf Grpc REQUIRED)</div>
<div class="line">...</div>
<div class="line">target_link_libraries(clienttutorial PRIVATE QtProtobuf::Grpc QtProtobuf::Protobuf)</div>
</div><!-- fragment --><p> At this point you will have full access to QtProtobuf libraries and macroses.</p>
<h2><a class="anchor" id="clienttutorial_generation"></a>
Generate code</h2>
<p>Let's imagine you have echo sever with following protocol definition saved to tutorial.proto: </p><div class="fragment"><div class="line">syntax=<span class="stringliteral">&quot;proto3&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">package </span>qtprotobuf.tutorial;</div>
<div class="line"> </div>
<div class="line">message EchoRequest {</div>
<div class="line">  <span class="keywordtype">string</span> message = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message EchoResponse {</div>
<div class="line">  <span class="keywordtype">string</span> message = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">service EchoService {</div>
<div class="line">  rpc Echo(EchoRequest) returns (EchoResponse);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Integration with your Qt application starts at point when you add protobuf and gRPC generation for .proto filed. Add <a class="el" href="group__generator.html#cmake_qtprotobuf_generate">qtprotobuf_generate</a> function to your CMakeLists.txt as following:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">add_executable(clienttutorial main.cpp qml.qrc) #Add QtProtobuf generator rules after CMake target defined</div>
<div class="line"> </div>
<div class="line">qtprotobuf_generate(TARGET clienttutorial QML TRUE PROTO_FILES tutorial.proto)</div>
<div class="line">...</div>
</div><!-- fragment --><p>We specified <code>QML TRUE</code> to have generated classes visibled in QML. At this point we have direct access to all classes specified in tutorial.proto from C++ and QML contexts.</p>
<p>To use them in C++ you need to include tutorial.qpb.h to get all messages defined in tutorial.proto accessible in C++ context: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tutorial.qpb.h&quot;</span></div>
</div><!-- fragment --><p>To access messages from QML code add appropriate import of protobuf package: </p><div class="fragment"><div class="line"><span class="keyword">import</span> qtprotobuf.tutorial 1.0</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All QML imports by default generated with version 1.0.</dd></dl>
<h2><a class="anchor" id="clienttutorial_cpp"></a>
Implement client-side business logic</h2>
<p>Now lets go deeper and try to interact with server using our gRPC API. For server communication we will have C++ model, that implements business logic and encapsulates QtGrpc client for communication purpose:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tutorial.qpb.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;tutorial_grpc.qpb.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EchoClientEngine : <span class="keyword">public</span> QObject</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">    Q_PROPERTY(qtprotobuf::tutorial::EchoResponse *response READ response CONSTANT)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> EchoClientEngine(QObject *parent = <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">    Q_INVOKABLE <span class="keywordtype">void</span> request(qtprotobuf::tutorial::EchoRequest *req);</div>
<div class="line"> </div>
<div class="line">    qtprotobuf::tutorial::EchoResponse *response()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_response.get();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;qtprotobuf::tutorial::EchoServiceClient&gt; m_client;</div>
<div class="line">    std::unique_ptr&lt;qtprotobuf::tutorial::EchoResponse&gt; m_response;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Here we specify our interface to communicate to QML part.</p>
<ul>
<li><code>response</code> property provides recent response from server. We made it CONSTANT because pointer it selves don't need any modifications.</li>
<li><code>request</code> invocable function expects pointer to EchoRequest, that will be utilized to call Echo remote procedure.</li>
<li><code>m_client</code> keeps pointer to generated EchoServerClient.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This implementation is one of possible usage of client-side grpc API.</dd></dl>
<p>Definition part of EchoClientEngine includes two main points:</p>
<ol type="1">
<li>Initialization of gRPC channel and attaching our EchoServiceClient to it.</li>
<li>Implement request call</li>
</ol>
<p>For gRPC channel we will use Http2 protocol without credentials. Simply create new channel with <a class="el" href="classQtProtobuf_1_1QGrpcInsecureChannelCredentials.html">QGrpcInsecureChannelCredentials</a> / <a class="el" href="classQtProtobuf_1_1QGrpcInsecureCallCredentials.html">QGrpcInsecureCallCredentials</a> and pass it as parameter to <a class="el" href="classQtProtobuf_1_1QAbstractGrpcClient.html#adea66681c070760360cf8330a2848f90">attachChannel</a> call right in constructor:</p>
<div class="fragment"><div class="line">EchoClientEngine::EchoClientEngine(QObject *parent) : QObject(parent), m_client(new EchoServiceClient), m_response(new EchoResponse)</div>
<div class="line">{</div>
<div class="line">    m_client-&gt;attachChannel(std::shared_ptr&lt;QAbstractGrpcChannel&gt;(<span class="keyword">new</span> QGrpcHttp2Channel(QUrl(<span class="stringliteral">&quot;http://localhost:65000&quot;</span>),</div>
<div class="line">                                                                                        QGrpcInsecureChannelCredentials()|QGrpcInsecureCallCredentials())));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Request function is very simple only utilizes generated Echo method, one of possible implementations as below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> EchoClientEngine::request(qtprotobuf::tutorial::EchoRequest *req)</div>
<div class="line">{</div>
<div class="line">    m_client-&gt;Echo(*req, m_response.get());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's stop at parameters, that we pass to <code>Echo</code> method. First parameter is request. Methods generated by QtProtobuf pass only reference to method argument, that's why we derefence it and provide as value. Second parameter is pointer to response that will be modified when server response will be received. Important point here is that responce value passed as QPointer and its time of life is controlled by grpc client. In case if pointer was removed client will ignore server response silently. So from this perspective QtGrpc provides to you async response safety.</p>
<p>We complete our model implementation, and it's time to make it visible in QML context. Simply do it in main:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">#include &lt;QtProtobufTypes&gt;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;echoclientengine.h</span></div>
<div class="line"><span class="preprocessor">...</span></div>
<div class="line"><span class="preprocessor">int main(int argc, char *argv[])</span></div>
<div class="line"><span class="preprocessor">{</span></div>
<div class="line"><span class="preprocessor">... </span><span class="comment">//Before load QML</span></div>
<div class="line">    QtProtobuf::qRegisterProtobufTypes();</div>
<div class="line">    qmlRegisterSingletonType&lt;EchoClientEngine&gt;(<span class="stringliteral">&quot;qtprotobuf.tutorial&quot;</span>, 1, 0, <span class="stringliteral">&quot;EchoClientEngine&quot;</span>, [](QQmlEngine *engine, QJSEngine *){</div>
<div class="line">        <span class="keyword">static</span> EchoClientEngine echoEngine;</div>
<div class="line">        engine-&gt;setObjectOwnership(&amp;echoEngine, QQmlEngine::CppOwnership);</div>
<div class="line">        <span class="keywordflow">return</span> &amp;echoEngine;</div>
<div class="line">    });</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's important to call <code>qRegisterProtobufTypes</code> to register all QtProtobuf types including generated user types. In our case it's types generated from tutorial.proto.</p>
<h2><a class="anchor" id="clienttutorial_qml"></a>
Implement client-side UI and interact to business logic</h2>
<p>Let's move to presentation part. Of course it's better to use QML when we describe our project UI:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> QtQuick 2.12</div>
<div class="line"><span class="keyword">import</span> QtQuick.Window 2.12</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> QtQuick.Controls 2.12</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> qtprotobuf.tutorial 1.0</div>
<div class="line"> </div>
<div class="line">Window {</div>
<div class="line">...</div>
<div class="line">    EchoRequest {</div>
<div class="line">        id: request</div>
<div class="line">        message: messageInput.text</div>
<div class="line">    }</div>
<div class="line">...</div>
<div class="line">    TextField {</div>
<div class="line">        id: messageInput</div>
<div class="line">        anchors.verticalCenter: parent.verticalCenter</div>
<div class="line">        width: 400</div>
<div class="line">        onAccepted: {</div>
<div class="line">            echoEngine.request(request);</div>
<div class="line">            text = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">...</div>
<div class="line">    Text {</div>
<div class="line">        anchors.verticalCenter: parent.verticalCenter</div>
<div class="line">        text: echoEngine.response.message</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>After cut off all fancy QML stuff, only QtProtobuf related things are left. Its important to do not forget import of our freshly generated qtprotobuf.tutorial package. At this point we have access to any message inside qtprotobuf.tutorial package. So we create view model right in QML code by adding <code>EchoRequest</code> object and bind <code>message</code> property to messageInput text. </p><dl class="section note"><dt>Note</dt><dd>It's not mandatory and in some cases may cause often field update, but in out case it's just tutorial ¯\_(ツ)_/¯.</dd></dl>
<p>Only thing left is to call our request method. We pass request that already contains text, that we would like to send to server. Result will be received and written to echoEngine.response.message property. We bound it to appropriate text field, that will be updated "immediately".</p><ul>
<li>It's time for testing! For tests you may use test server from projects <code>examples/tutorial/tutorialserver</code> folder. Run "build_and_run.sh" script in <code>examples/tutorial/tutorialserver</code> folder and enjoy echo functionality of your QtProtobuf EchoService client UI.</li>
</ul>
<h2><a class="anchor" id="clienttutorial_feedback"></a>
Feedback</h2>
<p>Please provide feedback using this <a href="https://github.com/semlanik/qtprotobuf/issues/116">issue</a> in project bug tracker.</p>
<h2><a class="anchor" id="clienttutorial_references"></a>
References</h2>
<p><a href="https://github.com/semlanik/qtprotobuf/tree/master/examples/clienttutorial">Complete tutorial code</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
